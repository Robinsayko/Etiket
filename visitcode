@app.on_message(filters.command("skorssk"))
async def ratingsa(c:Client, m:Message):
    if message.chat.type == "private":
        return await message.reply(f"{nogroup}")

    metin = """**🎖️  Global Top 20  🎖️**

"""
    eklenen = 1
    s = sorted(rating.items(), key=lambda x: x[1], reverse=True)
    for kisi in s:
        if eklenen == 1:
            metin +=  f"🥇  **{kisi[0]}  :  {kisi[1]}  Puan**\n" 
        if eklenen == 2:
            metin +=  f"🥈  **{kisi[0]}  :  {kisi[1]}  Puan**\n"
        if eklenen == 3:
            metin +=  f"🥉  **{kisi[0]}  :  {kisi[1]}  Puan**\n"
        if  not eklenen in [1,2,3]:
            metin +=  f" **{eklenen})  {kisi[0]}**  :  **{kisi[1]}  Puan**\n" 
        eklenen+=1
        if eklenen == 21:
            break
    await c.send_message(m.chat.id, metin)


import os
import re
from datetime import datetime, timedelta
import asyncio

import lyricsgenius as lg
from bs4 import BeautifulSoup

GENIUS_API_TOKEN = "VpT8NFnj4pTAYgaqAQj4eCIBCJk5ajA_F_PkFH-hH38Q8XhcEwT2Ro-NMWZ7vtfd"

class Lyric:
    def __init__(self, lyric, artist, title, image_url, url):
        self.lyric = lyric
        self.artist = artist
        self.title = title
        self.image_url = image_url
        self.url = url

async def get_lyrics(title: str):
    geniusClient = lg.Genius(
        GENIUS_API_TOKEN,
        skip_non_songs=True,
        verbose=False,
        excluded_terms=["(Remix)", "(Live)"],
        remove_section_headers=True,
    )

    def handler(lyrics: str):
        def remove_embed(lyrics: str):
            lyrics = re.sub(r"\d*Embed", "", lyrics)
            return lyrics

        def remove_first_line(lyrics: str):
            return "\n".join(lyrics.split("\n")[1:])

        return remove_first_line(remove_embed(lyrics))

    try:
        S = geniusClient.search_song(title, get_full_info=False)
        lyric = handler(S.lyrics)
        artist = S.artist
        title = S.title
        image_url = S.song_art_image_url
        url = S.url
        return Lyric(lyric, artist, title, image_url, url)
    except:
        return None

@app.on_message(filters.command(["lyrics"]))
async def lyrics(client: Client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            f"Kullanım:\n/{message.command[0]} <şarkı adı>"
        )
        return

    song_name = message.text.split(None, 1)[1]

    msg = await message.reply_text("🔎 Şarkı sözleri aranıyor...")

    lyric = await get_lyrics(song_name)
    if lyric is None:
        await msg.edit(f"Şarkı sözleri bulunamadı: {song_name}")
        return

    title = lyric.title
    artist = lyric.artist
    lyrics = lyric.lyric
    url = lyric.url
    image_url = lyric.image_url

    text = f"<b>🎈 Şarkı : {title}</b>\n\n"
    text += f"<b>🎂 Sanatçı : {artist}</b>\n\n"
    text += f"{lyrics}\n\n"

    if len(text) > 4096:
        text = text[:4050] + f"devamını oku ... {url}"
        await msg.edit(text, disable_web_page_preview=True)
        return
    else:
        text += f"<b>🌹 Kaynak : {url}</b>"
        await msg.edit(text, disable_web_page_preview=True)
        return


@client.on(events.NewMessage(pattern='^/stats ?(.*)'))
async def son_durum(event):
    # Bot Stats 
    if str(event.sender_id) not in SUDO_USERS:
        return await event.reply("**Sen sudo değilsin. Botun Statiklerini Öğrenemezsin!")
    global anlik_calisan,grup_sayi,ozel_list
    sender = await event.get_sender()
    if sender.id not in ozel_list:
      return
    await event.respond(f"**{bot_username} İstatistikleri 🤖**\n\nToplam Grup: `{len(grup_sayi)}`\nAnlık Çalışan Grup: `{len(anlik_calisan)}`")


@client.on(events.NewMessage(pattern="^/reload$"))
async def reload_vps(event):
    try:
        # Mesajı gönder
        reload_message = await event.respond("VPS Yenileniyor... ⏳ Bu birkaç saniye sürebilir.")

        # 10 saniye bekleyin
        await asyncio.sleep(10)

        # Mesajı güncelle
        await reload_message.edit("VPS Yenilendi! ✅")
    except Exception as e:
        # Hata durumunda mesaj gönder
        await event.respond(f"Hata oluştu: {str(e)}")


@client.on(events.NewMessage(pattern="^/sozluk (.+)$"))
async def sozluk_command(event):
    try:
        # Komuttan kelimeyi al
        query_word = event.pattern_match.group(1)

        # API'ye isteği gönder
        api_url = "https://api.collectapi.com/dictionary/wordSearchTurkish"
        headers = {
            'content-type': 'application/json',
            'authorization': 'apikey 4vummoAcfHEEdB2quMSNKK:3xpnojA2cyhcuZ8MM7LG6C'
        }
        params = {
            'query': query_word
        }

        response = requests.get(api_url, headers=headers, params=params)

        if response.status_code == 200:
            dictionary_data = response.json()
            if dictionary_data.get("success", False):
                word_info_list = dictionary_data.get("result", [])
                
                # Sadece ilk anlamı al
                first_word_info = word_info_list[0] if word_info_list else {}

                madde = first_word_info.get('madde', {})
                kelime_sayi = madde.get('kelime_sayı', 'Bilgi Yok')
                kelime_list = madde.get('kelime', [])

                message = f"📖 Sözlük Anlamı ({query_word}):\n\n"

                for kelime in kelime_list:
                    anlam = kelime.get('anlam', 'Bilgi Yok')
                    ornek_list = kelime.get('ornek', [])
                    ozellik_list = kelime.get('ozellik', [])

                    for ornek in ornek_list:
                        ornek_metni = ornek.get('ornek', 'Bilgi Yok')
                        yazar = ornek.get('yazar', 'Bilgi Yok')

                        ornek_message = (
                            f"🔸 Anlam: {anlam}\n"
                            f"🔸 Örnek: {ornek_metni}\n"
                        )

                        message += ornek_message

                    for ozellik in ozellik_list:
                        tam_adi = ozellik.get('tamAdı', 'Bilgi Yok')
                        kisa_adi = ozellik.get('kısaAdı', 'Bilgi Yok')

                        ozellik_message = (
                            f"🔸 Özellik: {tam_adi} ({kisa_adi})\n"
                        )

                        message += ozellik_message

                    message += "\n"

                # Mesajı gönder
                await event.respond(message)
            else:
                await event.respond("Sözlük anlamı bulunamadı.")
        else:
            await event.respond(f"Hata oluştu. HTTP Status Code: {response.status_code}")

    except Exception as e:
        # Hata durumunda mesaj gönder
        await event.respond(f"Hata oluştu: {str(e)}")



bot_token = '6404904263:AAHP25SjaF85qCncHTq5NE9zA4A-ASD5XNA'

bot_active = False

bot = telebot.TeleBot(bot_token)

# /yas komutuna yanıt veren bir işlev
@bot.message_handler(commands=['yas'])
def calculate_age(message):
    try:
        # Komutu kullanan kullanıcının doğum tarihini alın
        birthday_str = message.text.split()[-1]
        birthday = datetime.strptime(birthday_str, "%d.%m.%Y")

        # Şu anki tarihi alın
        current_date = datetime.now()

        # Kullanıcının yaşını hesaplayın
        age = current_date.year - birthday.year - ((current_date.month, current_date.day) < (birthday.month, birthday.day))

        # Doğum gününün ne kadar zaman sonra olduğunu hesaplayın
        next_birthday = datetime(current_date.year, birthday.month, birthday.day)
        if current_date > next_birthday:
            next_birthday = datetime(current_date.year + 1, birthday.month, birthday.day)
        days_until_birthday = (next_birthday - current_date).days

        # Kullanıcıya cevap verin
        reply_message = f"🎉 sᴇᴠɢɪʟɪ {message.from_user.first_name}\n"
        reply_message += f"💭 şᴜᴀɴᴅᴀ {age} ʏᴀşɪɴᴅᴀsɪɴ .\n\n"
        reply_message += f"🎂 ᴅᴏɢ̆ᴜᴍ ɢᴜ̈ɴᴜ̈ɴ {days_until_birthday} ɢᴜ̈ɴ sᴏɴʀᴀ ."
        bot.reply_to(message, reply_message)
    except ValueError:
        bot.reply_to(message, "🗒️ ɢᴇᴄ̧ᴇʀsɪᴢ ᴛᴀʀɪʜ .\nᴅᴏɢ̆ʀᴜ ʙɪʀ ᴛᴀʀɪʜ ɢɪʀɪɴ .\nᴏ̈ʀɴᴇᴋ : 30.01.2000")
    except Exception as e:
        bot.reply_to(message, "🗒️ ʙɪʀ ʜᴀᴛᴀ ᴏʟᴜşᴛᴜ .\nsᴏɴʀᴀ ᴛᴇᴋʀᴀʀ ᴅᴇɴᴇʏɪɴ .")

# /burc komutuna yanıt veren bir işlev
@bot.message_handler(commands=['burc'])
def calculate_zodiac_sign(message):
    try:
        # Komutu kullanan kullanıcının doğum tarihini alın
        birthday_str = message.text.split()[-1]
        birthday = datetime.strptime(birthday_str, "%d.%m.%Y")

        # Burçları ve tarih aralıklarını tanımlayın
        zodiac_signs = [
            {"name": "𝗄𝗈𝖼̧", "start_date": datetime(birthday.year, 3, 21), "end_date": datetime(birthday.year, 4, 19)},
            {"name": "𝖻𝗈𝗀̆𝖺", "start_date": datetime(birthday.year, 4, 20), "end_date": datetime(birthday.year, 5, 20)},
            {"name": "𝗂𝗄𝗂𝗓𝗅𝖾𝗋", "start_date": datetime(birthday.year, 5, 21), "end_date": datetime(birthday.year, 6, 20)},
            {"name": "𝗒𝖾𝗇𝗀𝖾𝖼̧", "start_date": datetime(birthday.year, 6, 21), "end_date": datetime(birthday.year, 7, 22)},
            {"name": "𝖺𝗌𝗅𝖺𝗇", "start_date": datetime(birthday.year, 7, 23), "end_date": datetime(birthday.year, 8, 22)},
            {"name": "𝖻𝖺𝗌̧𝖺𝗄", "start_date": datetime(birthday.year, 8, 23), "end_date": datetime(birthday.year, 9, 22)},
            {"name": "𝗍𝖾𝗋𝖺𝗓𝗂", "start_date": datetime(birthday.year, 9, 23), "end_date": datetime(birthday.year, 10, 22)},
            {"name": "𝖺𝗄𝗋𝖾𝗉", "start_date": datetime(birthday.year, 10, 23), "end_date": datetime(birthday.year, 11, 21)},
            {"name": "𝗒𝖺𝗒", "start_date": datetime(birthday.year, 11, 22), "end_date": datetime(birthday.year, 12, 21)},
            {"name": "𝗈𝗀̆𝗅𝖺𝗄", "start_date": datetime(birthday.year, 12, 22), "end_date": datetime(birthday.year, 1, 19)},
            {"name": "𝗄𝗈𝗏𝖺", "start_date": datetime(birthday.year, 1, 20), "end_date": datetime(birthday.year, 2, 18)},
            {"name": "𝖻𝖺𝗅ı𝗄", "start_date": datetime(birthday.year, 2, 19), "end_date": datetime(birthday.year, 3, 20)},
        ]

        # Kullanıcının burcunu bulun
        zodiac_sign = None
        for sign in zodiac_signs:
            if sign["start_date"] <= birthday <= sign["end_date"]:
                zodiac_sign = sign["name"]
                break

        if zodiac_sign:
            bot.reply_to(message, f"💭 {birthday_str} ᴛᴀʀɪʜɪɴᴅᴇ \n🌟 ᴅᴏɢ̆ᴅᴜɢ̆ᴜɴᴜᴢᴀ ɢᴏ̈ʀᴇ ...\n\n✓ ʙᴜʀᴄᴜɴᴜᴢ : {zodiac_sign}")
        else:
            bot.reply_to(message, "🗒️ ɢᴇᴄ̧ᴇʀsɪᴢ ᴛᴀʀɪʜ ᴠᴇʏᴀ ʙᴜʀᴄ̧ ʜᴇsᴀᴘʟᴀɴᴀᴍᴀᴅɪ ...")
    except ValueError:
        bot.reply_to(message, "🗒️ ɢᴇᴄ̧ᴇʀsɪᴢ ᴛᴀʀɪʜ .\nᴅᴏɢ̆ʀᴜ ʙɪʀ ᴛᴀʀɪʜ ɢɪʀɪɴ .\nᴏ̈ʀɴᴇᴋ : 30.01.2000")
    except Exception as e:
        bot.reply_to(message, "🗒️ ʙɪʀ ʜᴀᴛᴀ ᴏʟᴜşᴛᴜ .\nsᴏɴʀᴀ ᴛᴇᴋʀᴀʀ ᴅᴇɴᴇʏɪɴ .")

# SUS KOMUTUNA YANIT VEREN BİR İŞLEV
@bot.message_handler(commands=['susjdkrkr'])
def deactivate_bot(message):
    global bot_active
    bot_active = False
    bot.reply_to(message, "Bot şu an pasif.")

# KONUS KOMUTUNA YANIT VEREN BİR İŞLEV
@bot.message_handler(commands=['konuskdjdk'])
def activate_bot(message):
    global bot_active
    bot_active = True
    bot.reply_to(message, "Bot şu an aktif.")

# İP KOMUTUNA YANIT VEREN BİR İŞLEV
@bot.message_handler(commands=['ipdndjr'])
def ip_sorgu(message):
    try:
        ip = message.text.split()[-1]

        # IP sorgusu işlemi
        response = requests.get(f"http://ip-api.com/json/{ip}").json()

        if response["status"] == "success":
            # IP sorgusu başarılı ise sonucu özelleştirin
            result = "🌐 IP Bilgileri 🌐\n\n"
            result += f"🔹 **IP Adresi:** `{response['query']}`\n"
            result += f"🔹 **Ülke:** `{response['country']}`\n"
            result += f"🔹 **Şehir:** `{response['city']}`\n"
            result += f"🔹 **Posta Kodu:** `{response['zip']}`\n"
            result += f"🔹 **Koordinatlar:** `{response['lat']}, {response['lon']}`\n"

            bot.reply_to(message, result)
        else:
            bot.reply_to(message, "IP sorgusu başarısız oldu.")
    except IndexError:
        bot.reply_to(message, "❌ İşlem Başarısız\n❗️ Lütfen Geçerli Bir IP Adresi Giriniz!\n\nÖrnek: /ip 8.8.8.8")
    except Exception as e:
        bot.reply_to(message, "❌ Bir Hata Oluştu\n\nLütfen Daha Sonra Tekrar Deneyin. . .⏳")

# DNS KOMUTUNU İŞLEYİN
@bot.message_handler(commands=['dnsjsdjkd'])
def dns_sorgu(message):
    try:
        domain = message.text.split()[-1]

        # DNS sorgusu işlemi
        response = requests.get(f"http://ip-api.com/json/{domain}").json()

        if response["status"] == "success":
            # DNS sorgusu başarılı ise sonucu özelleştirin
            result = "🌐 DNS Sorgusu 🌐\n\n"
            result += f"🔹 **Domain Adı:** `{domain}`\n"
            result += f"🔹 **IP Adresi:** `{response['query']}`\n"

            bot.reply_to(message, result, parse_mode='Markdown')
        else:
            bot.reply_to(message, "❌ DNS sorgusu başarısız oldu veya bu domain için herhangi bir IP adresi bulunamadı.")
    except IndexError:
        bot.reply_to(message, "❌ İşlem Başarısız\n❗️ Lütfen Geçerli Bir Domain Adı Giriniz!\n\nÖrnek: /dns example.com")
    except Exception as e:
        bot.reply_to(message, f"❌ Bir Hata Oluştu\n\nHata Detayı: {str(e)}")

# Bot'u çalıştırın
while True:
    try:
        bot.polling(none_stop=True)
    except Exception as e:
        pass
